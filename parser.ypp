%{
  #include <stdlib.h> /* Required to compile with C++ */
  #include <stdio.h>
  #include <ctype.h>
  #include <math.h>
  #include "global.h"
  #include "TreeNode.h"
  extern int yylex(void);
  extern int yyparse(); /* Required to compile with C++ */
  extern void yyerror(char*); /* Required to compile with C++ */
%}

%token  NUM DONE DIV MOD ID

%left '='
%left '?' ':'
%left '<' '>'
%left '+' '-'
%left '*' '/' MOD '%' '&' '|'
%left '^'


%union {
  int i;
  TreeNode* p;
}

%type <p> expr;
%type <p> statement;

%type <i> NUM;
%type <i> ID;

%%

program:
        statement '.' { TreeNode::printTree($1); }
        ;


statement:
        expr ';' statement        { $$ = TreeNode::makeNode(';', $1) }
        |                         { printf("empty\n"); }
        ;

expr:
        NUM                       { $$ = TreeNode::makeLeaf(NUM, $1) }
        | ID                      { $$ = TreeNode::makeLeaf(ID, $1) }
        | ID '=' expr             { $$ = TreeNode::makeNode('=', TreeNode::makeLeaf(ID, $1), $3) }
        | expr '+' expr           { $$ = TreeNode::makeNode('+', $1, $3) }
        | expr '-' expr           { $$ = TreeNode::makeNode('-', $1, $3) }
        | expr '*' expr           { $$ = TreeNode::makeNode('*', $1, $3) }
        | expr '/' expr           { $$ = TreeNode::makeNode('/', $1, $3) }
        | expr '^' expr           { $$ = TreeNode::makeNode('^', $1, $3) }
        | expr MOD expr           { $$ = TreeNode::makeNode(MOD, $1, $3) }
        | expr '%' expr           { $$ = TreeNode::makeNode('%', $1, $3) }
        | expr '&' expr           { $$ = TreeNode::makeNode('&', $1, $3) }
        | expr '|' expr           { $$ = TreeNode::makeNode('|', $1, $3) }
        | expr '<' expr           { $$ = TreeNode::makeNode('<', $1, $3) }
        | expr '>' expr           { $$ = TreeNode::makeNode('>', $1, $3) }
        | '(' expr ')'            { $$ = $2; }
        ;

%%

void yyerror(char *s) {
  fprintf(stderr, "%s\n", s);
}

